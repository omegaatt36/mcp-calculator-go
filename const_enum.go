// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package main

import (
	"errors"
	"fmt"
)

const (
	// ArgumentOp is a Argument of type op.
	ArgumentOp Argument = "op"
	// ArgumentX is a Argument of type x.
	ArgumentX Argument = "x"
	// ArgumentY is a Argument of type y.
	ArgumentY Argument = "y"
)

var ErrInvalidArgument = errors.New("not a valid Argument")

// String implements the Stringer interface.
func (x Argument) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Argument) IsValid() bool {
	_, err := ParseArgument(string(x))
	return err == nil
}

var _ArgumentValue = map[string]Argument{
	"op": ArgumentOp,
	"x":  ArgumentX,
	"y":  ArgumentY,
}

// ParseArgument attempts to convert a string to a Argument.
func ParseArgument(name string) (Argument, error) {
	if x, ok := _ArgumentValue[name]; ok {
		return x, nil
	}
	return Argument(""), fmt.Errorf("%s is %w", name, ErrInvalidArgument)
}

const (
	// OperationAdd is a Operation of type add.
	OperationAdd Operation = "add"
	// OperationSub is a Operation of type sub.
	OperationSub Operation = "sub"
	// OperationMul is a Operation of type mul.
	OperationMul Operation = "mul"
	// OperationDiv is a Operation of type div.
	OperationDiv Operation = "div"
)

var ErrInvalidOperation = errors.New("not a valid Operation")

// String implements the Stringer interface.
func (x Operation) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Operation) IsValid() bool {
	_, err := ParseOperation(string(x))
	return err == nil
}

var _OperationValue = map[string]Operation{
	"add": OperationAdd,
	"sub": OperationSub,
	"mul": OperationMul,
	"div": OperationDiv,
}

// ParseOperation attempts to convert a string to a Operation.
func ParseOperation(name string) (Operation, error) {
	if x, ok := _OperationValue[name]; ok {
		return x, nil
	}
	return Operation(""), fmt.Errorf("%s is %w", name, ErrInvalidOperation)
}
